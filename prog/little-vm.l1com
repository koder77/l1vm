// little-vm.l1com
// Brackets - a little VM running an add numbers loop
//
// This is an exammple how to use "jsra" and "loadl".
//
#include <intr.l1h>
(main func)
	(set int64 1 zero 0)
	(set int64 1 one 1)
	(set byte 14 bytecode 10 0 1 0 29 0 2 5 39 5 0 40 0 41)
	(set int64 14 jmp_array)
	(set int64 256 regi)
	(set double 256 regd)
	(set int64 1 arg1 0)
	(set int64 1 arg2 0)
	(set int64 1 arg3 0)
	(set int64 1 ep 0)
	(set int64 1 bp 0)
	(set int64 1 offset 8)
	(set int64 1 ind 0)
	// (set int64 1 maxloop 10000000000)
	(set int64 1 maxloop 10000000)
	(zero regi [ ind ] =)
	((ind offset +) ind =)
	(one regi [ ind ] =)
	((ind offset +) ind =)
	(maxloop regi [ ind ] =)
	(set string s messagestr "starting...")
	print_s (messagestr)
	print_n
	(:start !)
	exit (zero)
(funcend)
(addi func)
	#var ~ @addi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 four~ 4)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 32)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg2 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg3 =)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	((arg2 offset~ *) arg2 =)
	((arg3 offset~ *) arg3 =)
	(regi [ arg1 ] r1~ =)
	(regi [ arg2 ] r2~ =)
	((r1~ r2~ +) r3~ =)
	(r3~ regi [ arg3 ] =)
	((ep four~ +) ep =)
	((bp bp_offset~ +) bp =)
(funcend)
(lsi func)
	#var ~ @lsi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 four~ 4)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 32)
	(set int64 1 f 0)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((arg1 zero +) arg1 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg2 =)
	((arg2 zero +) arg2 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg3 =)
	((arg3 zero +) arg3 =)
	(reset-reg)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	((arg2 offset~ *) arg2 =)
	((arg3 offset~ *) arg3 =)
	(reset-reg)
	(regi [ arg1 ] r1~ =)
	(regi [ arg2 ] r2~ =)
	(((r1~ r2~ <) f =) f if+)
		(reset-reg)
		(one regi [ arg3 ] =)
	(else)
		(reset-reg)
		(zero regi [ arg3 ] =)
	(endif)
	((ep four~ +) ep =)
	((bp bp_offset~ +) bp =)
(funcend)
(jmpi func)
	#var ~ @jmpi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 three~ 3)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 24)
	(set int64 1 f 0)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((arg1 zero +) arg1 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg2 =)
	((arg2 zero +) arg2 =)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	(regi [ arg1 ] r1~ =)
	(((r1~ zero !=) f =) f if+)
		(reset-reg)
		(arg2 ep =)
		(arg2 bp =)
		((bp offset~ *) bp =)
	(else)
		(reset-reg)
		((ep three~ +) ep =)
		((bp bp_offset~ +) bp =)
	(endif)
(funcend)
(printi func)
	#var ~ @printi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 two~ 2)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 16)
	(set int64 1 f 0)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((arg1 zero +) arg1 =)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	(regi [ arg1 ] r1~ =)
	print_i (r1~)
	print_n
	((ep two~ +) ep =)
	((bp bp_offset~ +) bp =)
(funcend)
(end func)
	exit (zero)
(funcend)
(create_jumptable func)
	#var ~ @create_jumptable
	(set int64 1 ind~ 0)
	(set int64 1 max_code~ 0)
	(set int64 1 opcode~ 0)
	(set int64 1 f~ 0)
	(set int64 1 offset~ 8)
	(set int64 1 jmp_ind~ 0)
	// opcodes as in L1VM:
	(set int64 1 op_addi~ 10)
	(set int64 1 op_lsi~ 29)
	(set int64 1 op_jmpi~ 39)
	// different from C L1VM for now:
	(set int64 1 op_printi~ 40)
	(set int64 1 op_end~ 41)
	(set int64 1 lab_addi~ 0)
	(set int64 1 lab_lsi~ 0)
	(set int64 1 lab_jmpi~ 0)
	(set int64 1 lab_printi~ 0)
	(set int64 1 lab_end~ 0)
	(set int64 1 one~ 1)
	(set int64 1 two~ 2)
	(set int64 1 three~ 3)
	(set int64 1 four~ 4)
	(max_code~ stpopi)
	(zero ind~ =)
	(zero jmp_ind~ =)
	(:addi lab_addi~ loadl)
	(:lsi lab_lsi~ loadl)
	(:jmpi lab_jmpi~ loadl)
	(:printi lab_printi~ loadl)
	(:end lab_end~ loadl)
	((lab_addi~ zero +) lab_addi~ =)
	((lab_lsi~ zero +) lab_lsi~ =)
	((lab_jmpi~ zero +) lab_jmpi~ =)
	((lab_printi~ zero +) lab_printi~ =)
	((lab_end~ zero +) lab_end~ =)
	(:create_jumptable_loop)
	(((ind~ max_code~ >=) f~ =) f~ if)
		(:create_jumptable_end jmp)
	(endif)
	// print_i (ind~)
	// print_n
	(bytecode [ ind~ ] opcode~ =)
	(switch)
		(opcode~ op_addi~ ?)
			((ind~ offset~ *) jmp_ind~ =)
			(lab_addi~ jmp_array [ jmp_ind~ ] =)
			// set address for next opcode
			((ind~ four~ +) ind~ =)
			(break)
		(opcode~ op_lsi~ ?)
			((ind~ offset~ *) jmp_ind~ =)
			(lab_lsi~ jmp_array [ jmp_ind~ ] =)
			// set address for next opcode
			((ind~ four~ +) ind~ =)
			(break)
		(opcode~ op_jmpi~ ?)
			((ind~ offset~ *) jmp_ind~ =)
			(lab_jmpi~ jmp_array [ jmp_ind~ ] =)
			// set address for next opcode
			((ind~ three~ +) ind~ =)
			(break)
		(opcode~ op_printi~ ?)
			((ind~ offset~ *) jmp_ind~ =)
			(lab_printi~ jmp_array [ jmp_ind~ ] =)
			// set address for next opcode
			((ind~ two~ +) ind~ =)
			(break)
		(opcode~ op_end~ ?)
			((ind~ offset~ *) jmp_ind~ =)
			(lab_end~ jmp_array [ jmp_ind~ ] =)
			// set address for next opcode
			((ind~ one~ +) ind~ =)
			(break)
	(switchend)
	(:create_jumptable_loop jmp)
	(:create_jumptable_end)
(funcend)
(start func)
	(set int64 1 ep 0)
	(set int64 1 i 0)
	(set int64 1 offset 8)
	(set int64 1 op_label 0)
	(set int64 1 max_opcodes 14)
	(reset-reg)
	(max_opcodes :create_jumptable !)
	(reset-reg)
	(zero i =)
	(zero bp =)
	(:load_opcode)
	(reset-reg)
	(jmp_array [ bp ] op_label =)
	(op_label jsra)
	(:load_opcode jmp)
(funcend)
