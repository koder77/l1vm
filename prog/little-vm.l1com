// little-vm.l1com
// Brackets - a little VM running an add numbers loop
//
// This is an exammple how to use "jsra" and "loadl".
//
// about 1000 points on Lenovo L340: Intel(R) Core(TM) i5-9300HF CPU @ 2.40GHz
// Single core benchmark!
//
#include <intr.l1h>
#include <math-const.l1h>
(main func)
	(set int64 1 zero 0)
	(set int64 1 one 1)
	(set byte 14 bytecode 10 0 1 0 29 0 2 5 39 5 0 40 0 41)
	(set int64 14 jmp_array)
	(set int64 256 regi)
	(set double 256 regd)
	(set int64 1 arg1 0)
	(set int64 1 arg2 0)
	(set int64 1 arg3 0)
	(set int64 1 ep 0)
	(set int64 1 bp 0)
	(set int64 1 offset 8)
	(set int64 1 ind 0)
	// (set int64 1 maxloop 1000)
	(set int64 1 maxloop 10000000)
	// timing save variable
	(set int64 1 time_ms_i 0)
	(zero :math_init !)
	(zero regi [ ind ] =)
	((ind offset +) ind =)
	(one regi [ ind ] =)
	((ind offset +) ind =)
	(maxloop regi [ ind ] =)
	(set string s messagestr "starting...")
	print_s (messagestr)
	print_n
	(:start !)
	exit (zero)
(funcend)
(opcodes_per_sec func)
	(set double 1 time_ms_d 0.0)
	(set double 1 opcodes_loop_d 195.0)
	(set double 1 maxloop_d 0.0)
	(set double 1 opcodes_sec_d 0.0)
	(set double 1 ticks_per_sec_d 1000.0)
	(set double 1 points_ref_d 37469016.0)
	(set double 1 points_d 0.0)
	(set int64 1 points_i 0)
	(set double 1 thousand_d 1000.0)
	(set string s opcodes_str "opcodes per sec: ")
	(set string s points_str "points: ")
	(time_ms_i :math_int2double !)
	(time_ms_d stpopd)
	(maxloop :math_int2double !)
	(maxloop_d stpopd)
	{opcodes_sec_d = ((maxloop_d * opcodes_loop_d) * ticks_per_sec_d / time_ms_d)}
	print_s (opcodes_str)
	print_d (opcodes_sec_d)
	print_n
	// calculate points
	{points_d = (thousand_d / points_ref_d) * opcodes_sec_d}
	(points_d :math_double2int !)
	(points_i stpopi)
	print_n
	print_s (points_str)
	print_i (points_i)
	print_n
(funcend)
(addi func)
	#var ~ @addi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 four~ 4)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 32)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg2 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg3 =)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	((arg2 offset~ *) arg2 =)
	((arg3 offset~ *) arg3 =)
	(regi [ arg1 ] r1~ =)
	(regi [ arg2 ] r2~ =)
	((r1~ r2~ +) r3~ =)
	(r3~ regi [ arg3 ] =)
	((ep four~ +) ep =)
	((bp bp_offset~ +) bp =)
(funcend)
(lsi func)
	#var ~ @lsi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 four~ 4)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 32)
	(set int64 1 f 0)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((arg1 zero +) arg1 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg2 =)
	((arg2 zero +) arg2 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg3 =)
	((arg3 zero +) arg3 =)
	(reset-reg)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	((arg2 offset~ *) arg2 =)
	((arg3 offset~ *) arg3 =)
	(reset-reg)
	(regi [ arg1 ] r1~ =)
	(regi [ arg2 ] r2~ =)
	(((r1~ r2~ <) f =) f if+)
		(reset-reg)
		(one regi [ arg3 ] =)
	(else)
		(reset-reg)
		(zero regi [ arg3 ] =)
	(endif)
	((ep four~ +) ep =)
	((bp bp_offset~ +) bp =)
(funcend)
(jmpi func)
	#var ~ @jmpi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 three~ 3)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 24)
	(set int64 1 f 0)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((arg1 zero +) arg1 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg2 =)
	((arg2 zero +) arg2 =)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	(regi [ arg1 ] r1~ =)
	(((r1~ zero !=) f =) f if+)
		(reset-reg)
		(arg2 ep =)
		(arg2 bp =)
		((bp offset~ *) bp =)
	(else)
		(reset-reg)
		((ep three~ +) ep =)
		((bp bp_offset~ +) bp =)
	(endif)
(funcend)
(printi func)
	#var ~ @printi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 two~ 2)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 16)
	(set int64 1 f 0)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((arg1 zero +) arg1 =)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	(regi [ arg1 ] r1~ =)
	print_i (r1~)
	print_n
	((ep two~ +) ep =)
	((bp bp_offset~ +) bp =)
(funcend)
(end func)
	(25 time_ms_i 0 0 intr0)
	{time_ms_i = (time_ms_i + zero)}
	(:opcodes_per_sec !)
	exit (zero)
(funcend)
(create_jumptable func)
	#var ~ @create_jumptable
	(set int64 1 ind~ 0)
	(set int64 1 max_code~ 0)
	(set int64 1 opcode~ 0)
	(set int64 1 f~ 0)
	(set int64 1 offset~ 8)
	(set int64 1 jmp_ind~ 0)
	// opcodes as in L1VM:
	(set int64 1 op_addi~ 10)
	(set int64 1 op_lsi~ 29)
	(set int64 1 op_jmpi~ 39)
	// different from C L1VM for now:
	(set int64 1 op_printi~ 40)
	(set int64 1 op_end~ 41)
	(set int64 1 lab_addi~ 0)
	(set int64 1 lab_lsi~ 0)
	(set int64 1 lab_jmpi~ 0)
	(set int64 1 lab_printi~ 0)
	(set int64 1 lab_end~ 0)
	(set int64 1 one~ 1)
	(set int64 1 two~ 2)
	(set int64 1 three~ 3)
	(set int64 1 four~ 4)
	(max_code~ stpopi)
	(zero ind~ =)
	(zero jmp_ind~ =)
	(:addi lab_addi~ loadl)
	(:lsi lab_lsi~ loadl)
	(:jmpi lab_jmpi~ loadl)
	(:printi lab_printi~ loadl)
	(:end lab_end~ loadl)
	((lab_addi~ zero +) lab_addi~ =)
	((lab_lsi~ zero +) lab_lsi~ =)
	((lab_jmpi~ zero +) lab_jmpi~ =)
	((lab_printi~ zero +) lab_printi~ =)
	((lab_end~ zero +) lab_end~ =)
	(:create_jumptable_loop)
	(((ind~ max_code~ >=) f~ =) f~ if)
		(:create_jumptable_end jmp)
	(endif)
	// print_i (ind~)
	// print_n
	(bytecode [ ind~ ] opcode~ =)
	(switch)
		(opcode~ op_addi~ ?)
			((ind~ offset~ *) jmp_ind~ =)
			(lab_addi~ jmp_array [ jmp_ind~ ] =)
			// set address for next opcode
			((ind~ four~ +) ind~ =)
			(break)
		(opcode~ op_lsi~ ?)
			((ind~ offset~ *) jmp_ind~ =)
			(lab_lsi~ jmp_array [ jmp_ind~ ] =)
			// set address for next opcode
			((ind~ four~ +) ind~ =)
			(break)
		(opcode~ op_jmpi~ ?)
			((ind~ offset~ *) jmp_ind~ =)
			(lab_jmpi~ jmp_array [ jmp_ind~ ] =)
			// set address for next opcode
			((ind~ three~ +) ind~ =)
			(break)
		(opcode~ op_printi~ ?)
			((ind~ offset~ *) jmp_ind~ =)
			(lab_printi~ jmp_array [ jmp_ind~ ] =)
			// set address for next opcode
			((ind~ two~ +) ind~ =)
			(break)
		(opcode~ op_end~ ?)
			((ind~ offset~ *) jmp_ind~ =)
			(lab_end~ jmp_array [ jmp_ind~ ] =)
			// set address for next opcode
			((ind~ one~ +) ind~ =)
			(break)
	(switchend)
	(:create_jumptable_loop jmp)
	(:create_jumptable_end)
(funcend)
(start func)
	(set int64 1 ep 0)
	(set int64 1 i 0)
	(set int64 1 offset 8)
	(set int64 1 op_label 0)
	(set int64 1 max_opcodes 14)
	(reset-reg)
	(max_opcodes :create_jumptable !)
	(reset-reg)
	(zero i =)
	(zero bp =)
	start_timer
	(:load_opcode)
	(reset-reg)
	(jmp_array [ bp ] op_label =)
	(op_label jsra)
	(:load_opcode jmp)
(funcend)
#include <math-lib.l1h>
