// little-vm.l1com
// Brackets - a little VM running an add numbers loop
//
// This is an exammple how to use "jsra" and "loadl".
//
#include <intr.l1h>
#include <math-const.l1h>
(main func)
	(set int64 1 zero 0)
	(set int64 1 one 1)
	(set byte 14 bytecode 10 0 1 0 29 0 2 5 39 5 0 40 0 41)
	(set int64 256 regi)
	(set double 256 regd)
	(set int64 1 arg1 0)
	(set int64 1 arg2 0)
	(set int64 1 arg3 0)
	(set int64 1 ep 0)
	(set int64 1 bp 0)
	(set int64 1 offset 8)
	(set int64 1 ind 0)

	(set int64 1 time_ms_i 0)

	// (set int64 1 maxloop 10000000000)
	(set int64 1 maxloop 10000000)
	(zero :math_init !)
	(zero regi [ ind ] =)
	((ind offset +) ind =)
	(one regi [ ind ] =)
	((ind offset +) ind =)
	(maxloop regi [ ind ] =)
	(set string s messagestr "starting...")
	print_s (messagestr)
	print_n
	(:start !)
	exit (zero)
(funcend)
(opcodes_per_sec func)
	(set double 1 time_ms_d 0.0)
	(set double 1 opcodes_loop_d 195.0)
	(set double 1 maxloop_d 0.0)
	(set double 1 opcodes_sec_d 0.0)
	(set double 1 ticks_per_sec_d 1000.0)
	(set double 1 points_ref_d 37469016.0)
	(set double 1 points_d 0.0)
	(set int64 1 points_i 0)
	(set double 1 thousand_d 1000.0)
	(set string s opcodes_str "opcodes per sec: ")
	(set string s points_str "points: ")
	(time_ms_i :math_int2double !)
	(time_ms_d stpopd)
	(maxloop :math_int2double !)
	(maxloop_d stpopd)
	{opcodes_sec_d = ((maxloop_d * opcodes_loop_d) * ticks_per_sec_d / time_ms_d)}
	print_s (opcodes_str)
	print_d (opcodes_sec_d)
	print_n
	// calculate points
	{points_d = (thousand_d / points_ref_d) * opcodes_sec_d}
	(points_d :math_double2int !)
	(points_i stpopi)
	print_n
	print_s (points_str)
	print_i (points_i)
	print_n
(funcend)
(addi func)
	#var ~ @addi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 four~ 4)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 32)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg2 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg3 =)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	((arg2 offset~ *) arg2 =)
	((arg3 offset~ *) arg3 =)
	(regi [ arg1 ] r1~ =)
	(regi [ arg2 ] r2~ =)
	((r1~ r2~ +) r3~ =)
	(r3~ regi [ arg3 ] =)
	((ep four~ +) ep =)
	((bp bp_offset~ +) bp =)
(funcend)
(lsi func)
	#var ~ @lsi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 four~ 4)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 32)
	(set int64 1 f 0)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((arg1 zero +) arg1 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg2 =)
	((arg2 zero +) arg2 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg3 =)
	((arg3 zero +) arg3 =)
	(reset-reg)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	((arg2 offset~ *) arg2 =)
	((arg3 offset~ *) arg3 =)
	(reset-reg)
	(regi [ arg1 ] r1~ =)
	(regi [ arg2 ] r2~ =)
	(((r1~ r2~ <) f =) f if+)
		(reset-reg)
		(one regi [ arg3 ] =)
	(else)
		(reset-reg)
		(zero regi [ arg3 ] =)
	(endif)
	((ep four~ +) ep =)
	((bp bp_offset~ +) bp =)
(funcend)
(jmpi func)
	#var ~ @jmpi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 three~ 3)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 24)
	(set int64 1 f 0)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((arg1 zero +) arg1 =)
	((bp~ one +) bp~ =)
	(bytecode [ bp~ ] arg2 =)
	((arg2 zero +) arg2 =)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	(regi [ arg1 ] r1~ =)
	(((r1~ zero !=) f =) f if+)
		(reset-reg)
		(arg2 ep =)
		(arg2 bp =)
		((bp offset~ *) bp =)
	(else)
		(reset-reg)
		((ep three~ +) ep =)
		((bp bp_offset~ +) bp =)
	(endif)
(funcend)
(printi func)
	#var ~ @printi
	(set int64 1 bp~ 0)
	(set int64 1 r1~)
	(set int64 1 r2~)
	(set int64 1 r3~)
	(set int64 1 two~ 2)
	(set int64 1 offset~ 8)
	(set int64 1 bp_offset~ 16)
	(set int64 1 f 0)
	((ep one +) bp~ =)
	(bytecode [ bp~ ] arg1 =)
	((arg1 zero +) arg1 =)
	// add offset 8 to registers
	((arg1 offset~ *) arg1 =)
	(regi [ arg1 ] r1~ =)
	print_i (r1~)
	print_n
	((ep two~ +) ep =)
	((bp bp_offset~ +) bp =)
(funcend)
(end func)
	(25 time_ms_i 0 0 intr0)
	{time_ms_i = (time_ms_i + zero)}
	(:opcodes_per_sec !)
	exit (zero)
(funcend)
(start func)
	(set int64 1 lsi_pos 32)
	(set int64 1 jmpi_pos 64)
	(set int64 1 printi_pos 88)
	(set int64 1 end_pos 104)
	(set int64 1 lab_addi 0)
	(set int64 1 lab_lsi 0)
	(set int64 1 lab_jmpi 0)
	(set int64 1 lab_printi 0)
	(set int64 1 lab_end 0)
	(set int64 14 jmp_array)
	(set int64 1 ep 0)
	(set int64 1 i 0)
	(set int64 1 offset 8)
	(set int64 1 op_label 0)
	(reset-reg)
	(:set_labels)
	(:addi lab_addi loadl)
	(:lsi lab_lsi loadl)
	(:jmpi lab_jmpi loadl)
	(:printi lab_printi loadl)
	(:end lab_end loadl)
	(:pull_labels)
	((lab_addi zero +) lab_addi =)
	((lab_lsi zero +) lab_lsi =)
	((lab_jmpi zero +) lab_jmpi =)
	((lab_printi zero +) lab_printi =)
	((lab_end zero +) lab_end =)
	(reset-reg)
	// save labels into jump array
	(zero i =)
	(lab_addi jmp_array [ i ] =)
	(lab_lsi jmp_array [ lsi_pos ] =)
	(lab_jmpi jmp_array [ jmpi_pos ] =)
	(lab_printi jmp_array [ printi_pos ] =)
	(lab_end jmp_array [ end_pos ] =)
	(zero bp =)
	start_timer
	(:load_opcode)
	(reset-reg)
	(jmp_array [ bp ] op_label =)
	(op_label jsra)
	(:load_opcode jmp)
(funcend)
#include <math-lib.l1h>
