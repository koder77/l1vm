// hello-thread-2.l1com
// Brackets - Hello world! threads
//
// This is an exammple how to launch threads using the new compiler opcode "loadl".
#include <intr.l1h>
(main func)
	(set const-int64 1 zero 0)
	(set int64 1 run 0)
	(set int64 1 f 0)
	(set const-int64 1 delay 4000)
	(set int64 1 cpu 0)
	(set string s infostr "starting threads...")
	// run the two threads
	//print_i (cpu)
	// print_n
	(((cpu zero ==) f =) f if)
	    print_s (infostr)
	    print_n
		(:start_thread !)
	    detime (delay)
		(one run =)
	(endif)
	exit (zero)
(funcend)
(hello_a func)
	#var ~ hello_a
	(set string s hellostr~ "Hello world! thread 1")
	(set const-int64 1 delay~ 2000)
	print_s (hellostr~)
    print_n
    detime (delay~)
(funcend)
(hello_b func)
    #var ~ hello_b
	(set string s hellostr~ "Hello world! thread 2")
	(set const-int64 1 delay~ 2000)
	print_s (hellostr~)
    print_n
    detime (delay~)
(funcend)
(start_thread func)
	(set int64 1 run_th 0)
	(set int64 1 lab_hello_one 0)
	(set int64 1 lab_hello_two 0)
	(set int64 1 zero_th 0)
	(set int64 1 one_th 1)
	(set int64 1 f_th 0)
	(set int64 1 delay_th 2500)
	(reset-reg)
	(:hello_a lab_hello_one loadl)
	(:hello_b lab_hello_two loadl)
	(((run_th zero_th ==) f_th =) f_th if)
		// run threads
		//thread (lab_hello_one)
        // thread (lab_hello_two)
        (0 lab_hello_one 0 0 intr1)
        (0 lab_hello_two 0 0 intr1)
		(one_th run_th =)
	(endif)
    detime (delay_ch)
    join
	threadexit (zero)
(funcend)
