// the flashing pattern function using RS232 direct library
(flash_pattern func)
	#var ~ flash_pattern
	(set int64 1 zero~ 0)
	(set int64 1 one~ 1)
	(set byte 1 address~ 0)
	(set byte 1 i~ 160)
	(set byte 1 checksum_send~ 0)
	(set byte 1 checksum_rec~ 0)
	(set int64 1 baudrate~ 19200)
	(set string s modestr~ "8N1")
	(set int64 1 retcode~ 0)
	(set int64 1 f~ 0)
	(set string 4096 buf~ "")
	(set int64 1 bufsize~ 4095)
	(set int64 1 readsize~ 0)
	(set string s ready_endstr~ "V1.0 ready")
	(set string s open_port_failstr~ "can't open serial port!")
	(set string s get_port_numberfailstr~ "can't get port number!")
	(set string s open_port_okstr~ "serial port opened")
	(set string s receive_readystr~ "LED POV 8 ready for flashing...")
	(set string s read_errorstr~ "can't read 1 byte!")
	(set string s write_errorstr~ "can't write 1 byte!")
	(set string s flashstr~ "flashing LED POV 8...")
	(set string s fopenerrstr~ "ERROR: can't open pattern file!")
	(set string s freaderrstr~ "ERROR: can't read pattern file!")
	(set int64 1 delay~ 100)
	(set int64 1 shandle~ 0)
	(set int64 1 fhandle~ 0)
	(set byte 1 mode_read~ 1)
	(set int64 1 ind~ 0)
	(set int64 1 ret~ 0)
	(set int64 1 ch~ 0)
	(set string 256 bufstr~ "")
	(set int64 1 bufstrlen~ 0)
	(set int64 1 buflen~ 0)
	(set string 2 chstr~ "")
	(set string s quotechstr~ "'")
	(set int64 1 newline~ 10)
	(set string 2 newlinestr~ "")
	(set int64 1 flash_ind~ 0)
	(set int64 1 flash_max~ 127)
    (flash_ind~ :update_flash_progress call)
	(newline~ newlinestr~ :string_bytenumtostring call)
	(:flash_text_reset call)
	// get port number
	(port_valuestr :rs232_get_port_number call)
	(shandle~ stpopi)
    (((shandle~ zero~ <) f~ =) f~ if)
		print_s (get_port_numberfailstr~)
		print_n
		// error can't open port
		(:flash_pattern_print_error call)
		(:flash_pattern_end jmp)
	(endif)
	(shandle~ baudrate~ modestr~ :rs232_open_comport call)
	(retcode~ stpopi)
	(((retcode~ zero~ !=) f~ =) f~ if+)
		print_s (open_port_failstr~)
		print_n
		// error can't open port
		(:flash_pattern_print_error call)
		(:flash_pattern_end jmp)
	(else)
		print_s (open_port_okstr~)
		print_n
	(endif)
	// wait for "V1.0 ready" message
	(:flash_pattern_loop_wait)
	(shandle~ buf~ bufsize~ :rs232_poll_comport call)
	(readsize~ stpopi)
	(((readsize~ zero~ <=) f~ =) f~ if)
		print_s (read_errorstr~)
		print_n
		detime (delay~)
		(:flash_pattern_loop_wait jmp)
	(endif)
	print_s (quotechstr~)
	print_s (buf~)
	print_s (quotechstr~)
	print_n
	// compare read byte with ready message
	(buf~ ready_endstr~ :string_compare call)
	(retcode~ stpopi)
	(((retcode~ zero~ ==) f~ =) f~ if+)
		print_s (receive_readystr~)
		print_n
	(else)
		(:flash_pattern_loop_wait jmp)
	(endif)
	(:flash_pattern_start)
	// got "V1.0 ready" message, flash patterns now
	print_s (flashstr~)
	print_n
	(zero ind~ =)
	// open pattern input file
	(mode_read~ filevaluestr :file_open call)
	(fhandle~ stpopi)
	(((fhandle~ zero <) f~ =) f~ if)
		// error can't open file
		print_s (fopenerrstr~)
		print_n
		(:flash_pattern_print_error call)
		(:flash_pattern_end jmp)
	(endif)
	(:flash_loop)
		(fhandle~ bufstr~ buflen~ :file_get_string call)
		(ret~ stpopi)
		(((ret~ zero~ !=) f~ =) f~ if)
			// EOF, exit flash loop
			(:flash_pattern_cleanup jmp)
		(endif)
		// add newline to read buffer
		(bufstr~ newlinestr~ :string_cat call)
		print_s (quotechstr~)
		print_s (bufstr~)
		print_s (quotechstr~)
		print_n
		(bufstr~ :string_len call)
		(bufstrlen~ stpopi)
		detime (delay~)
		// send byte buffer to serial port
		(shandle~ bufstr~ bufstrlen~ :rs232_send_buf call)
		(ret~ stpopi)
		(((ret~ zero <) f =) f if)
			print_s (write_errorstr~)
			print_n
			(:flash_pattern_print_error call)
			(:flash_pattern_end jmp)
		(endif)
		((flash_ind~ one~ +) flash_ind~ =)
	    (flash_ind~ :update_flash_progress call)
		(((flash_ind~ flash_max~ <=) f =) f if)
			(:flash_loop jmp)
		(endif)
	(:flash_pattern_cleanup)
	(shandle~ :rs232_close_comport call)
	(fhandle~ :file_close call)
	(zero~ flash_ind~ =)
	(:flash_pattern_print_ok call)
	(:flash_pattern_end)
(funcend)
