// json.l1h
// json string parsing library
// you have to include: mem-obj-lib.l1h and string.l1h in your program
// see lib/json.l1com
//
(entries_json func)
    #var ~ entries_json
    (set const-int64 1 zero~ 0)
    (set const-int64 1 one~ 1)
    (set int64 1 Pjson_str~)
    (set int64 1 entries~ 0)
    (set int64 1 i~ 0)
    (set string s colon_str~ ":")
    (set string 2 char_str~ "")
    (set int64 1 json_strlen~ 0)
    (set int64 1 ret~ 0)
    (set int64 1 f~ 0)
    (Pjson_str~ stpop)
    (Pjson_str~ :string_len !)
    (json_strlen~ stpop)
    (zero~ entries~ =)
    ((json_strlen~ one~ -) json_strlen~ =)
    (zero~ i~ =)
    (zero~ entries~ =)
    (do)
        (Pjson_str~ char_str~ i~ :string_mid !)
        // check if char_str~ is colon
        (char_str~ colon_str~ :string_compare !)
        (ret~ stpop)
        (((ret~ zero~ ==) f~ =) f~ if)
            ((entries~ one~ +) entries~ =)
        (endif)
        ((i~ one~ +) i~ =)
    (((i~ json_strlen~ <) f~ =) f~ while)
    (entries~ stpush)
(funcend)

(split_json func)
    #var ~ split_json
    (set const-int64 1 zero~ 0)
    (set const-int64 1 one~ 1)
    (set int64 1 Pjson_str~)
    (set int64 1 Pentry_str~)
    (set int64 1 i~ 0)
    (set int64 1 start~ 0)
    (set string 2 comma_str~ "")
    (set int64 1 comma_ascii~ 44)
    (set string s cbracket_str~ "{")
    (set string 2 char_str~ "")
    (set string s empty_str~ "")
    (set int64 1 json_strlen~ 0)
    (set int64 1 ret~ 0)
    (set int64 1 f~ 0)
    (set int64 1 comma_not_found -1)
    (start~ Pentry_str~ Pjson_str~ stpop)
    (comma_ascii~ comma_str~ :string_bytenumtostring !)
    (Pentry_str~ empty_str~ :string_copy !)
    (Pjson_str~ :string_len !)
    (json_strlen~ stpop)
    ((json_strlen~ one~ -) json_strlen~ =)
    (start~ i~ =)
    (do)
        (Pjson_str~ char_str~ i~ :string_mid !)
        // check if char_str~ is comma
        (char_str~ comma_str~ :string_compare !)
        (ret~ stpop)
        (((ret~ zero~ ==) f~ =) f~ if+)
            (i~ stpush)
            (ASM)
            rts
            (ASM_END)
        (else)
            // add char-str~ to Pentry_str~ if it is not {
            (char_str~ cbracket_str~ :string_compare !)
            (ret~ stpop)
            (((ret~ zero~ !=) f~ =) f~ if)
                (Pentry_str~ char_str~ :string_cat !)
            (endif)
        (endif)
        ((i~ one~ +) i~ =)
    (((i~ json_strlen~ <) f~ =) f~ while)
    (comma_not_found stpush)
(funcend)

(get_json func)
    #var ~ get_json
    (set const-int64 1 zero~ 0)
    (set const-int64 1 one~ 1)
    (set const-int64 1 two~ 2)
    (set int64 1 Pentry_str~)
    (set int64 1 Pkey_str~)
    (set int64 1 Pvalue_str~)
    (set int64 1 i~ 0)
    (set int64 1 entry_strlen~ 0)
    (set int64 1 ret~ 0)
    (set int64 1 f~ 0)
    (set string 2 quote_str~ "")
    (set int64 1 quote_ascii~ 34)
    (set string s colon_str~ ":")
    (set string 2 char_str~ "")
    (set string s empty_str~ "")
    (set int64 1 quotes~ 0)
    (Pvalue_str~ Pkey_str~ Pentry_str~ stpop)
    (Pentry_str~ :string_len !)
    (entry_strlen~ stpop)
    ((entry_strlen~ one~ -) entry_strlen~ =)
    (quote_ascii~ quote_str~ :string_bytenumtostring !)
    // clear key and value
    (Pkey_str~ empty_str~ :string_copy !)
    (Pvalue_str~ empty_str~ :string_copy !)
    (zero~ quotes~ =)
    (zero~ i~ =)
    // get key
    (do)
        (Pentry_str~ char_str~ i~ :string_mid !)
        // check if char_str~ is quote "
        (char_str~ quote_str~ :string_compare !)
        (ret~ stpop)
        (((ret~ zero~ !=) f~ =) f~ if+)
            // no quote, add char if first quote found
            (((quotes~ one~ ==) f~ =) f~ if)
                (Pkey_str~ char_str~ :string_cat !)
            (endif)
        (else)
           ((quotes~ one~ +) quotes~ =)
           (((quotes~ two~ ==) f~ =) f~ if)
              // found closing quote, exit
              ((i~ one~ +) i~ =)
              (:get_json_get_value jmp)
           (endif)
        (endif)
        ((i~ one~ +) i~ =)
    (((i~ entry_strlen~ <) f~ =) f~ while)

    // get value
    (:get_json_get_value)
    (zero~ quotes~ =)
    (do)
        (Pentry_str~ char_str~ i~ :string_mid !)
        // check if char_str~ is quote "
        (char_str~ quote_str~ :string_compare !)
        (ret~ stpop)
        (((ret~ zero~ !=) f~ =) f~ if+)
            // no quote, check if colon :
            (char_str~ colon_str~ :string_compare !)
            (ret~ stpop)
            (((ret~ zero~ !=) f~ =) f~ if)
                // no quote, add char if first quote found
                (((quotes~ one~ ==) f~ =) f~ if)
                    (Pvalue_str~ char_str~ :string_cat !)
                (endif)
            (endif)
        (else)
           ((quotes~ one~ +) quotes~ =)
           (((quotes~ two~ ==) f~ =) f~ if)
              // found closing quote, exit
              ((i~ one~ +) i~ =)
              (:get_json_end jmp)
           (endif)
        (endif)
        ((i~ one~ +) i~ =)
    (((i~ entry_strlen~ <) f~ =) f~ while)
    (:get_json_end)
(funcend)

(parse_json func)
    #var ~ parse_json
    (set const-int64 1 zero~ 0)
    (set const-int64 1 one~ 1)
    (set const-int64 1 two~ 2)
    (set string 4096 json_str~ "")
    (set int64 1 memaddr~ 0)
    (set int64 1 vars~ 0)
    (set int64 1 index~ 0)
    (set int64 1 Pjson_str~)
    (set string 4096 json_entry_str~ "")
    (set int64 1 Pjson_entry_str~)
    (set string 4096 json_key_str~)
    (set int64 1 Pjson_key_str~)
    (set string 4096 json_value_str~)
    (set int64 1 Pjson_value_str~)
    (set int64 1 entries~ 0)
    (set int64 1 i~ 0)
    (set int64 1 ret~ 0)
    (set int64 1 f~ 0)
    (set int64 1 parse_start~ 0)
    (set int64 1 comma_pos~ 0)
    (set int64 1 json_mem_addr~ 0)
    (set int64 1 json_index~ 0)
    (set int64 1 json_max_entries~ 0)
    #include <mem-obj-lib-types.l1h>

    (json_index~ Pjson_str~ stpop)
    (json_entry_str~ Pjson_entry_str~ pointer)
    (json_key_str~ Pjson_key_str~ pointer)
    (json_value_str~ Pjson_value_str~ pointer)
    (zero~ i~ =)
    (zero~ parse_start~ =)

    // get number of json elements
    (Pjson_str~ :entries_json !)
    (entries~ stpop)
    (((entries~ zero~ ==) f~ =) f~ if)
       // no json entries found, return with error code zero
       (one~ stpushi)
       (ASM)
       rts
       (ASM_END)
    (endif)

    // allocate memory for the entry variables
    ((entries~ two~ *) json_max_entries~ =)
    (json_max_entries~ one~ :alloc_obj_memobj call)
    (json_mem_addr~ stpop)

    (for-loop)
    (((i~ entries~ <) f~ =) f~ for)
        (Pjson_str~ Pjson_entry_str~ parse_start~ :split_json !)
        (comma_pos~ stpop)
        (Pjson_entry_str~ Pjson_key_str~ Pjson_value_str~ :get_json !)
        (json_value_str~ s_type json_key_str~ s_type two~ json_index~ json_mem_addr~ :save_obj_memobj !)

        ((comma_pos~ one~ +) parse_start~ =)
        ((i~ one~ +) i~ =)
        ((json_index~ two~ +) json_index~ =)
   (next)
   (json_mem_addr~ entries~ stpush)
(funcend)
