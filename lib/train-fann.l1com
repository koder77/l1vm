// train-ann.l1com
// fann train library demo
// train XOR function and run trained neural network
#include <intr.l1h>
(main func)
    (set int64 1 zero 0)
    (set int64 1 one 1)
    (set int64 1 i 50000)
    (set int64 1 f 0)
    (set int64 1 ret 0)
    (set double 2 input1 -1.0 -1.0)
    (set double 2 input2 -1.0 1.0)
    (set double 2 input3 1.0 0.0)
    (set double 2 input4 1.0 1.0)
    (set double 1 des_output_null -1.0)
    (set double 1 des_output_one 1.0)
    (set double 1 output 1.0)
    (set int64 1 input1_addr 40)
    (set int64 1 input2_addr 56)
    (set int64 1 input3_addr 72)
    (set int64 1 input4_addr 88)
    (set int64 1 des_output_null_addr 104)
    (set int64 1 des_output_one_addr 112)
    (set int64 1 output_addr 120)
    (set int64 1 two 2)
    (set string 16 learning "learning xor...")
    (set string 10 txt_1 "0 xor 0: ")
    (set string 10 txt_2 "0 xor 1: ")
    (set string 10 txt_3 "1 xor 0: ")
    (set string 10 txt_4 "1 xor 1: ")
    (set string 11 run "running...")
	(set int64 1 handle 0)
    (set int64 1 three 3)
    (set int64 1 two 2)
    (set int64 1 layers 3)
    (set int64 1 inputs 2)
    (set int64 1 outputs 1)
    (set int64 1 hidden_neurons 3)
    (set string s create_str "creating xor fann...")

    // init fnann library
	(reset-reg)
    (zero one :fann_init_lib call)
	(ret stpopi)
    (loadreg)
	(((ret zero !=) f =) f if)
		(1 zero 0 0 intr0)
		(255 zero 0 0 intr0)
	(endif)
	(reset-reg)
	stack_check

    // create fann
    (6 create_str 0 0 intr0)
    (7 0 0 0 intr0)
    (layers inputs hidden_neurons outputs :fann_create !)
    (handle stpop)

    (loadreg)
    (4 ret 0 0 intr0)
    (7 0 0 0 intr0)
    (6 learningaddr 0 0 intr0)
    (7 0 0 0 intr0)
    (:learn)
    (handle input1_addr des_output_null_addr two one :fann_train call)
    (handle input4_addr des_output_null_addr two one :fann_train call)
    (handle input2_addr des_output_one_addr two one :fann_train call)
    (handle input3_addr des_output_one_addr two one :fann_train call)
    ((i one -) i =)
    ((i zero >) f =)
    (f :learn jmpi)
    // run ann
    (6 runaddr 0 0 intr0)
    (7 0 0 0 intr0)
    // run fann with one output variable
    (handle input1_addr output_addr two one :fann_run call)
    (loadreg)
    (6 txt_1addr 0 0 intr0)
    (5 output 0 0 intr0)
    (7 0 0 0 intr0)
    (handle input2_addr output_addr two one :fann_run call)
    (loadreg)
    (6 txt_2addr 0 0 intr0)
    (5 output 0 0 intr0)
    (7 0 0 0 intr0)
    (handle input3_addr output_addr two one :fann_run call)
    (loadreg)
    (6 txt_3addr 0 0 intr0)
    (5 output 0 0 intr0)
    (7 0 0 0 intr0)
    (handle input4_addr output_addr two one :fann_run call)
    (loadreg)
    (6 txt_4addr 0 0 intr0)
    (5 output 0 0 intr0)
    (7 0 0 0 intr0)
    (handle :fann_free call)
    (loadreg)
	(:free_fanns call)
	(loadreg)
    (1 zero 0 0 intr0)
    (255 zero 0 0 intr0)
(funcend)
#include <fann-lib.l1h>
