// go-data-run.l1com
//
// get client worker program name from l1vmgodata server
// and run the program with L1VM
//
#include <intr.l1h>
(main func)
    (set const-int64 1 zero 0)
    (set const-int64 1 one 1)
	(set const-int64 1 two 2)
	(set int64 1 portnum 2000Q)
	(set string 256 portstr "")
	(set string 4097 worker_id_str "")
	(set int64 1 error 0)
	(set int64 1 f 0)
	(set string 256 ip "127.0.0.1")
    (set string 256 hoststr)
    (set int64 1 ip_len 10)
    (set int64 1 ret 0)
    (set int64 1 socket_handle 0)
	(set const-int64 1 mod_string 0)
    (set const-int64 1 mod_net 1)
	(set const-int64 1 mod_process 2)
	(set const-int64 1 mod_math 3)
    (set string s netinitstr "error: can't init networking sockets!")
    (set string s addressstr "error can't get host address!")
    (set string s connectstr "error: can't connect to server!")
    (set string s readstr "error can't read data in data base!")
    (set string s dataokstr "data read OK!")
    (set string s dataerrstr "data read ERROR!")
    (set string s process_errstr "run process ERROR: can't run program!")
    (set string s call_str "l1vm go-data-run -args <ip> <port> <worker-id>")
    (set string 4097 retstr "")
    (set string 4097 runstr "./run-worker.sh ")
    (set string 4097 processstr "")
    (set string s errorstr "ERROR")
	(set string s worker_env_str "L1VMWORKERID")
    (set const-int64 1 delay 1000)
    (set const-int64 1 delay_end 5000)

    (set int64 1 args 0)
    (set int64 1 args_needed 3)

    #include <math-const.l1h>

	(mod_string :string_init !)
    (mod_net one :net_init !)
	(ret stpopi)
	(((ret zero !=) f =) f if)
		// ERROR can't allocate memory
        print_s (netinitstr)
        print_n
        exit (one)
	(endif)
	(mod_process :process_init call)
    (mod_math :math_init call)

    // get number of shell args
    shell_args (args)
    (((args args_needed <) f =) f if)
	    print_s (call_str)
	    print_n
	    exit (one)
	(endif)
	// read arguments
	// ip
	(reset-reg)
	get_shell_arg (zero, ip)
    print_s (ip)
    print_n
	// port
	get_shell_arg (one, portstr)
    (portstr :string_to_int !)
    (portnum stpopi)
    print_i (portnum)
    print_n
	// worker id
	get_shell_arg (two, worker_id_str)
    print_s (worker_id_str)
    print_n

    stack_check

    //set worker env variable
    (worker_env_str worker_id_str :set_env !)

    (reset-reg)
    (ip portnum :open_client_socket !)
    (ret stpopi)
    (socket_handle stpopi)
    print_i (ret)
    print_n
    (((ret zero !=) f =) f if)
		// ERROR can't connect to server
        print_s (connectstr)
        print_n
        exit (one)
	(endif)

    (:loop)
    // delay a second
    detime (delay)

    //stack_check

    (socket_handle worker_id_str retstr :go_data_remove !)
    (ret stpopi)
    (((ret zero !=) f =) f if)
		// ERROR can't connect to server
        print_s (readstr)
        print_n
        exit (one)
	(endif)
    print_s (dataokstr)
    print_n
    print_s (retstr)
    print_n

    // stack_check
    (reset-reg)
    (retstr errorstr :string_compare !)
    (ret stpopi)
    print_i (ret)
    print_n
    (((ret zero ==) f =) f if)
        // ERROR
        print_s (dataerrstr)
        print_n
        // (socket_handle :go_data_close !)
        // (ret stpopi)
        (:loop jmp)
    (endif)
    // run go-data-run.sh with the retstr value we got from server
    (processstr runstr :string_copy !)
    (processstr retstr :string_cat !)
    // run process
    (processstr :run_shell call)
	(ret stpopi)
    (((ret zero !=) f =) f if)
        print_s (process_errstr)
        print_n
        exit (one)
    (endif)
    // close connection 
    // (socket_handle :go_data_close !)
    //(ret stpopi)
    // process finished jump to loop start
    //
    detime (delay_end)
    (:loop jmp)
    exit (zero)
(funcend)
#include <net-lib.l1h>
#include <string.l1h>
#include <l1vmgodata.l1h>
#include <process-lib.l1h>
#include <math-lib.l1h>
